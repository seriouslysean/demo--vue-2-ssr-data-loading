const { readFileSync } = require('fs');
const { join } = require('path');
const express = require('express');
const { createBundleRenderer } = require('vue-server-renderer');

function createRenderer(bundle, options) {
  // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
  return createBundleRenderer(bundle, Object.assign(options, {
    // recommended for performance
    runInNewContext: false,
    // this is only needed when vue-server-renderer is npm-linked
    basedir: join(__dirname, '../dist'),
    inject: true,
  }))
}

const app = express();

const templatePath = join(__dirname, 'index.template.html');

let renderer;
let readyPromise;
if (process.env.NODE_ENV === 'production') {
  // In production: create server renderer using template and built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  const template = readFileSync(templatePath, 'utf-8');
  const serverBundle = require('../dist/vue-ssr-server-bundle.json');
  // The client manifests are optional, but it allows the renderer
  // to automatically infer preload/prefetch links and directly add <script>
  // tags for any async chunks used during render, avoiding waterfall requests.
  const clientManifest = require('../dist/vue-ssr-client-manifest.json');
  renderer = createRenderer(serverBundle, {
    template,
    clientManifest,
  });
} else {
  // In development: setup the dev server with watch and hot-reload,
  // and create a new renderer on bundle / index template update.
  readyPromise = require('../config/setup-dev-server')(
    app,
    templatePath,
    (bundle, options) => {
      console.log(`HMR: Creating renderer`);
      renderer = createRenderer(bundle, options);
    }
  )
}

const staticPath = join(__dirname, '../dist');
app.use(express.static(staticPath, {
  fallthrough: process.env.NODE_ENV !== 'production',
  index: false,
}));

const render = (req, res) => {
  res.setHeader('Content-Type', 'text/html');
  const context = { url: req.url };
  renderer.renderToString(context, (err, html) => {
    if (err) {
      throw new Error(err);
    }
    res.end(html);
  });
}

app.get('*', process.env.NODE_ENV === 'production' ? render : (req, res) => {
  readyPromise.then(() => render(req, res));
});

app.listen(3000);
